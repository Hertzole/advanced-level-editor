[{"title":"Expose To Level Editor","type":0,"sectionRef":"#","url":"docs/attributes/exposetoleveleditor","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Expose To Level Editor","url":"docs/attributes/exposetoleveleditor#properties","content":"ExposeToLevelEditor comes with a few extra properties you can set to modify the exposed field/property. customName Allows you to set a name that should be shown in the runtime inspector.visible Allows you to hide the field/property from the runtime inspector. This does not stop it from being serialized. order Sets the order in the runtime inspector. Higher means lower down. "},{"title":"Usage​","type":1,"pageTitle":"Expose To Level Editor","url":"docs/attributes/exposetoleveleditor#usage","content":"using UnityEngine; using Hertzole.ALE; public class ExposedClass : MonoBehaviour { [ExposeToLevelEditor(0)] public int intValue; [ExposeToLevelEditor(1, customName = &quot;Text&quot;)] // Will show name as 'Text' private string stringValue; [ExposeToLevelEditor(2, visible = false)] // Will not show up in runtime inspector public float FloatValue { get; set; } [ExposeToLevelEditor(3, order = -10)] // Will be first in the runtime inspector public byte ByteValue { get; set; } } Copy "},{"title":"Formerly Hashed As","type":0,"sectionRef":"#","url":"docs/attributes/formerlyhashedas","content":"Formerly Hashed As FormerlyHashedAs is used for versioning whenever you update a serialized type and/or fields.","keywords":""},{"title":"Require Type","type":0,"sectionRef":"#","url":"docs/attributes/requiretype","content":"Require Type RequireType is a helper attribute that makes sure the user assigns a GameObject that has a specific component or interface on it. note This attribute does nothing in ALE. It's only for the Unity editor.","keywords":""},{"title":"Camera","type":0,"sectionRef":"#","url":"docs/components/camera","content":"Camera TODO","keywords":""},{"title":"Input","type":0,"sectionRef":"#","url":"docs/components/input","content":"Input TODO","keywords":""},{"title":"Level Editor","type":0,"sectionRef":"#","url":"docs/components/level-editor","content":"Level Editor TODO","keywords":""},{"title":"Level Editor Object","type":0,"sectionRef":"#","url":"docs/components/level-editor-object","content":"Level Editor Object TODO","keywords":""},{"title":"Object Manager","type":0,"sectionRef":"#","url":"docs/components/object-manager","content":"Object Manager TODO","keywords":""},{"title":"Manipulation Handle","type":0,"sectionRef":"#","url":"docs/components/manipulation-handle","content":"Manipulation Handle TODO","keywords":""},{"title":"Selection","type":0,"sectionRef":"#","url":"docs/components/selection","content":"Selection TODO","keywords":""},{"title":"Save Manager","type":0,"sectionRef":"#","url":"docs/components/save-manager","content":"Save Manager TODO","keywords":""},{"title":"Inspector","type":0,"sectionRef":"#","url":"docs/components/ui/inspector","content":"Inspector TODO","keywords":""},{"title":"Hierarchy","type":0,"sectionRef":"#","url":"docs/components/ui/hierarchy","content":"Hierarchy TODO","keywords":""},{"title":"UGUI","type":0,"sectionRef":"#","url":"docs/components/ui/ugui","content":"UGUI TODO","keywords":""},{"title":"Resource View","type":0,"sectionRef":"#","url":"docs/components/ui/resource-view","content":"Resource View TODO","keywords":""},{"title":"About Editor Modes","type":0,"sectionRef":"#","url":"docs/editor-modes/about-editor-modes","content":"About Editor Modes TODO","keywords":""},{"title":"Undo","type":0,"sectionRef":"#","url":"docs/components/undo","content":"Undo TODO","keywords":""},{"title":"Create A Mode","type":0,"sectionRef":"#","url":"docs/editor-modes/create-mode","content":"Create A Mode TODO","keywords":""},{"title":"Unified Mode","type":0,"sectionRef":"#","url":"docs/editor-modes/unified-mode","content":"Unified Mode TODO","keywords":""},{"title":"Level Editor Mode","type":0,"sectionRef":"#","url":"docs/editor-modes/level-editor-mode","content":"Level Editor Mode TODO","keywords":""},{"title":"Quick Start","type":0,"sectionRef":"#","url":"docs/getting-started/quick-start","content":"Quick Start The easiest way to get started with ALE right now is to important the 'Completed Scene' sample and modify that. Unfortunately, there's no simple way to set up ALE from scratch right now, so this will be the best way for now. Navigate to the package manager: Window → Package Manager.Make sure you're looking at the packages in your project. Click on 'Advanced Level Editor' under 'Hertzole'.Under 'Samples', click 'Import' on the 'Completed Scene' sample. Unity should now import a working sample for you to build upon and learn from.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/getting-started/installation","content":"Installation Currently, only the development package is available. It's updated with each commit to the master branch. Add the OpenUPM registry. Click in the menu bar Edit → Project Settings... → Package Manager Add a new scoped registry with the following parameters: Name: OpenUPM URL: https://package.openupm.com Scopes: com.openupm com.neuecc.messagepack Open the package manager and click 'Add from Git url' in the top right corner.Paste in https://github.com/Hertzole/advanced-level-editor.git#dev-package and click enter. Wait for the installation to complete. The package should now be installed! Check out the Quick Start to get up and running with ALE.","keywords":""},{"title":"Built-in Play Mode","type":0,"sectionRef":"#","url":"docs/playmode/builtin-playmode","content":"Built-in Play Mode TODO","keywords":""},{"title":"About Play Mode","type":0,"sectionRef":"#","url":"docs/playmode/aboutplaymode","content":"About Play Mode TODO","keywords":""},{"title":"Custom Play Mode","type":0,"sectionRef":"#","url":"docs/playmode/custom-playmode","content":"Custom Play Mode TODO","keywords":""},{"title":"C# Primitives","type":0,"sectionRef":"#","url":"docs/serialization/c-primitives","content":"C# Primitives The most common C# primitives can be used and serialized by the serializer. These types includebool, byte, sbyte, short, ushort, int, uint, long, ulong, float, decimal, double, string, and char. There's also some special structs that also can be serialized. These types include Guid, DateTime,TimeSpan, and Uri. It also supports all these types as an array (for example int[]), as lists (for example List&lt;int&gt;), and as nullable (for example int?).","keywords":""},{"title":"Custom Types","type":0,"sectionRef":"#","url":"docs/serialization/custom-types","content":"Custom Types When your type isn't a C# primitive or a Unity primitive, ALE will attempt to create a serializer for it. At the moment, only struct types can be serialized. For all the rules that apply when serializing a custom type, seeSerialization Rules/When serializing custom types. Generated Code This is the struct that it will serialize. public struct MyStruct { public int test1; public string test2; } Copy This is the generated formatter. using System; using Hertzole.ALE.Tests.TestScripts; using MessagePack; using MessagePack.Formatters; public class MyStruct_Formatter : IMessagePackFormatter&lt;MyStruct&gt;, IMessagePackFormatter { public void Serialize(ref MessagePackWriter writer, MyStruct value, MessagePackSerializerOptions options) { IFormatterResolver resolver = options.Resolver; writer.WriteArrayHeader(4); // Hashed from value1 writer.WriteInt32(768721960); writer.WriteInt32(value.test1); // Hashed from value2 writer.WriteInt32(768721961); resolver.GetFormatterWithVerify&lt;string&gt;().Serialize(ref writer, value.test2, options); } public MyStruct Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options) { if (reader.TryReadNil()) { throw new InvalidOperationException(&quot;typecode is null, struct not supported&quot;); } options.Security.DepthStep(ref reader); int test = 0; string test2 = null; DeserializeFormat1(ref reader, options, ref test, ref test2); MyStruct result = default(MyStruct); result.test1 = test; result.test2 = test2; reader.Depth--; return result; } private static void DeserializeFormat1(ref MessagePackReader P_0, MessagePackSerializerOptions P_1, ref int test1, ref string test2) { IFormatterResolver resolver = P_1.Resolver; int num = P_0.ReadArrayHeader(); for (int i = 0; i &lt; num / 2; i++) { switch (P_0.ReadInt32()) { case 768721960: // value1 test1 = P_0.ReadInt32(); break; case 768721961: // value2 test2 = P_0.ReadString(); break; default: P_0.Skip(); break; } } } } Copy","keywords":""},{"title":"About Serialization","type":0,"sectionRef":"#","url":"docs/serialization/about-serialization","content":"","keywords":""},{"title":"Exposed Components​","type":1,"pageTitle":"About Serialization","url":"docs/serialization/about-serialization#exposed-components","content":"ALE will serialize all components that have been exposed to the level editor. (See Expose To Level Editor attribute) It can serialize all the standardC# primitives, Unity primitives, and somecustom types. Generated Code This is the code that it will generate a wrapper and formatter from. using UnityEngine; using Hertzole.ALE; public class ExposedClass : MonoBehaviour { [ExposeToLevelEditor(0)] public int intValue; [ExposeToLevelEditor(1)] public string stringValue; } Copy First it creates a wrapper inside ExposeClass. using System.Collections.Generic; using System.Runtime.CompilerServices; using Hertzole.ALE; using MessagePack; public struct ALE__GENERATED__ExposedClassComponentWrapper : IExposedWrapper { public Dictionary&lt;int, object&gt; Values { get; set; } public Dictionary&lt;int, bool&gt; Dirty { get; set; } public void Serialize(int id, ref MessagePackWriter writer, MessagePackSerializerOptions options) { switch (id) { case 0: writer.WriteInt32((int)Values[0]); break; case 1: options.Resolver.GetFormatterWithVerify&lt;string&gt;().Serialize(ref writer, (string)Values[1], options); break; } } public object Deserialize(int id, ref MessagePackReader reader, MessagePackSerializerOptions options) { switch (id) { case 0: return reader.ReadInt32(); case 1: return reader.ReadString(); default: return null; } } } Copy Then lastly it creates the formatter. using System; using System.Collections.Generic; using MessagePack; using MessagePack.Formatters; public class ExposedClass_Formatter : IMessagePackFormatter&lt;ExposedClass.ALE__GENERATED__ExposedClassComponentWrapper&gt;, IMessagePackFormatter { public void Serialize(ref MessagePackWriter writer, ExposedClass.ALE__GENERATED__ExposedClassComponentWrapper wrapper, MessagePackSerializerOptions options) { writer.WriteArrayHeader(4); writer.WriteInt32(0); wrapper.Serialize(0, ref writer, options); writer.WriteInt32(1); wrapper.Serialize(1, ref writer, options); } public ExposedClass.ALE__GENERATED__ExposedClassComponentWrapper Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options) { if (reader.TryReadNil()) { throw new InvalidOperationException(); } options.Security.DepthStep(ref reader); int num = reader.ReadArrayHeader(); ExposedClass.ALE__GENERATED__ExposedClassComponentWrapper wrapper = default(ExposedClass.ALE__GENERATED__ExposedClassComponentWrapper); wrapper.Values = new Dictionary&lt;int, object&gt;(2); wrapper.Dirty = new Dictionary&lt;int, bool&gt;(2); for (int i = 0; i &lt; num / 2; i++) { switch (reader.ReadInt32()) { case 0: wrapper.Values[0] = wrapper.Deserialize(0, ref reader, options); wrapper.Dirty[0] = true; break; case 1: wrapper.Values[1] = wrapper.Deserialize(1, ref reader, options); wrapper.Dirty[1] = true; break; } } reader.Depth--; return wrapper; } } Copy "},{"title":"Custom Data​","type":1,"pageTitle":"About Serialization","url":"docs/serialization/about-serialization#custom-data","content":"Custom data is, as the name implies, custom data being saved with the level data when saving. You can save the standard C# primitives, Unity primitives, and some custom types in custom data and retrieve it later when loading a level. See save manager for more info about actually using custom data. "},{"title":"Serialization Rules​","type":1,"pageTitle":"About Serialization","url":"docs/serialization/about-serialization#serialization-rules","content":"There are some rules that the weaver follows to create formatters for your exposed components and custom types. They can be really helpful in order to get the most reliable output from your data. When serializing exposed components:​ Unity object/component references ARE allowedOnly specified fields and properties are serializedExposed properties are mapped to their IDPrivate, protected, and public fields/properties can be serialized When serializing custom types:​ Unity object/component references ARE NOT allowedOnly structs can be serializedOnly fields are serializedAll fields are serializedFields can be ignored with the NonSerializable attributeFields are mapped to their namesOnly public fields are serialized "},{"title":"Custom Formatters​","type":1,"pageTitle":"About Serialization","url":"docs/serialization/about-serialization#custom-formatters","content":"⚠ Custom formatters are not yet supported. ⚠ Custom formatters give you the ability to easily create your own formatter that will be hooked into the level editor so you can customize the serialization behavior of your custom types. "},{"title":"Unity Primitives","type":0,"sectionRef":"#","url":"docs/serialization/unity-primitives","content":"Unity Primitives The most common Unity primitives can be used and serialized by the serializer. These types includeAnimationCurve, Bounds, BoundsInt, Color32, Color, GradientAlphaKey, GradientColorKey, GradientFormatter,Keyframe, LayerMask, Matrix4x4, Quaternion, RangeInt, Rect, RectInt, RectOffset, Vector2, Vector2Int,Vector3, Vector3Int, Vector4, Vector4Int, and WrapMode It also supports all these types as an array (for example Color[]), as lists (for example List&lt;Color&gt;), and as nullable (for example Color?).","keywords":""}]